# 3 GIT其他文件操作
## 3.1 已提交删除的文件找回
如果一个文件已经提交删除，可以通过之前文章描述的“git reset --hard 指针版本号”切换到以往版本，找回被删除的文件：
```shell
xxx@DESKTOP MINGW64 /d/othergitrepository/data-struct (master)
$ git status
On branch master
nothing to commit, working tree clean

xxx@DESKTOP MINGW64 /d/othergitrepository/data-struct (master)
$ vim del.txt

xxx@DESKTOP MINGW64 /d/othergitrepository/data-struct (master)
$ git add del.txt
warning: in the working copy of 'del.txt', LF will be replaced by CRLF the next time Git touches it

xxx@DESKTOP MINGW64 /d/othergitrepository/data-struct (master)
$ git commit -m "add be deleted file" del.txt
warning: in the working copy of 'del.txt', LF will be replaced by CRLF the next time Git touches it
[master 97c6b65] add be deleted file
 1 file changed, 1 insertion(+)
 create mode 100644 del.txt

xxx@DESKTOP MINGW64 /d/othergitrepository/data-struct (master)
$ git status
On branch master
nothing to commit, working tree clean

xxx@DESKTOP MINGW64 /d/othergitrepository/data-struct (master)
$ rm del.txt

xxx@DESKTOP MINGW64 /d/othergitrepository/data-struct (master)
$ git status
On branch master
Changes not staged for commit:
  (use "git add/rm <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
        deleted:    del.txt

no changes added to commit (use "git add" and/or "git commit -a")

xxx@DESKTOP MINGW64 /d/othergitrepository/data-struct (master)
$ git add del.txt

xxx@DESKTOP MINGW64 /d/othergitrepository/data-struct (master)
$ git status
On branch master
Changes to be committed:
  (use "git restore --staged <file>..." to unstage)
        deleted:    del.txt


xxx@DESKTOP MINGW64 /d/othergitrepository/data-struct (master)
$ git commit -m "del del.txt" del.txt
[master 41f7439] del del.txt
 1 file changed, 1 deletion(-)
 delete mode 100644 del.txt

xxx@DESKTOP MINGW64 /d/othergitrepository/data-struct (master)
$ git status
On branch master
nothing to commit, working tree clean

xxx@DESKTOP MINGW64 /d/othergitrepository/data-struct (master)
$ ll
total 2
-rw-r--r-- 1 liecho 197610 48 Jun  9 23:35 init.txt
-rw-r--r-- 1 liecho 197610 23 Jun  7 19:37 second.txt

xxx@DESKTOP MINGW64 /d/othergitrepository/data-struct (master)
$ git reflog
41f7439 (HEAD -> master) HEAD@{0}: commit: del del.txt
97c6b65 HEAD@{1}: commit: add be deleted file
168ee26 HEAD@{2}: commit: second.txt commit
86c8478 HEAD@{3}: reset: moving to 86c8478
2a70b27 HEAD@{4}: reset: moving to HEAD^
86c8478 HEAD@{5}: reset: moving to 86c8478
2a70b27 HEAD@{6}: reset: moving to 2a70b27
86c8478 HEAD@{7}: commit: 第二次提交init.txt
2a70b27 HEAD@{8}: commit (initial): 首次提交init.txt

xxx@DESKTOP MINGW64 /d/othergitrepository/data-struct (master)
$ git reset --hard 97c6b65
HEAD is now at 97c6b65 add be deleted file

xxx@DESKTOP MINGW64 /d/othergitrepository/data-struct (master)
$ ll
total 3
-rw-r--r-- 1 liecho 197610  9 Jun 10 11:14 del.txt
-rw-r--r-- 1 liecho 197610 48 Jun  9 23:35 init.txt
-rw-r--r-- 1 liecho 197610 23 Jun  7 19:37 second.txt

xxx@DESKTOP MINGW64 /d/othergitrepository/data-struct (master)
$ git status
On branch master
nothing to commit, working tree clean
```

## 3.2 删除提交暂存区的文件找回
依旧使用“git reset --hard 指针版本号”命令，将指针指向最新HEAD指针即可：git reset --hard HEAD。  
因为删除提交暂存区时，本地库尚未被操作。
注意：所有使用git进行文件找回的前提是文件必须提交过一次本地库。  

## 3.3 文件差异对比（git diff）
命令：git diff [历史版本记录] 文件名
使用不带历史版本的命令“git diff 文件名”，表示将工作区中的文件和暂存区进行比较：
```shell
xxx@DESKTOP MINGW64 /d/othergitrepository/data-struct (master)
$ vim del.txt

xxx@DESKTOP MINGW64 /d/othergitrepository/data-struct (master)
$ git diff del.txt
diff --git a/del.txt b/del.txt
index 84c59d3..c2c733b 100644
--- a/del.txt
+++ b/del.txt
@@ -1 +1,3 @@
 dfafdsa
+
+gggg
```
当将文件添加到暂存区后，使用“git diff 文件名”进行对比不会出现任何结果,因为本地文件和暂存区的文件一致：
```shell
xxx@DESKTOP MINGW64 /d/othergitrepository/data-struct (master)
$ git add del.txt

xxx@DESKTOP MINGW64 /d/othergitrepository/data-struct (master)
$ git diff del.txt
```
通过“git diff [历史版本记录] 文件名”命令，可以将工作区中的文件和本地库的历史文件进行比较：
```shell
xxx@DESKTOP MINGW64 /d/othergitrepository/data-struct (master)
$ git diff HEAD del.txt
diff --git a/del.txt b/del.txt
index 84c59d3..c2c733b 100644
--- a/del.txt
+++ b/del.txt
@@ -1 +1,3 @@
 dfafdsa
+
+gggg

xxx@DESKTOP MINGW64 /d/othergitrepository/data-struct (master)
$ git diff HEAD^ del.txt
diff --git a/del.txt b/del.txt
new file mode 100644
index 0000000..c2c733b
--- /dev/null
+++ b/del.txt
@@ -0,0 +1,3 @@
+dfafdsa
+
+gggg
```
上述两个命令，分别将提交到暂存区的del.txt和当前本地库最新版本、次新版本（HEAD^）进行比较。  

不带文件名时，可以比较多个文件：
```shell
xxx@DESKTOP MINGW64 /d/othergitrepository/data-struct (master)
$ vim second.txt

xxx@DESKTOP MINGW64 /d/othergitrepository/data-struct (master)
$ git diff HEAD
warning: in the working copy of 'second.txt', LF will be replaced by CRLF the next time Git touches it
diff --git a/del.txt b/del.txt
index 84c59d3..c2c733b 100644
--- a/del.txt
+++ b/del.txt
@@ -1 +1,3 @@
 dfafdsa
+
+gggg
diff --git a/second.txt b/second.txt
index 269c38a..0ef8073 100644
--- a/second.txt
+++ b/second.txt
@@ -1 +1,2 @@
-this is the second file
\ No newline at end of file
+this is the second file
+3434`
```
如果想针对某些文件进行差异比对，可以给如多个文件名：
```shell
xxx@DESKTOP MINGW64 /d/othergitrepository/data-struct (master)
$ vim init.txt

xxx@DESKTOP MINGW64 /d/othergitrepository/data-struct (master)
$ git diff HEAD init.txt second.txt
warning: in the working copy of 'second.txt', LF will be replaced by CRLF the next time Git touches it
diff --git a/init.txt b/init.txt
index 051ba5b..193c026 100644
--- a/init.txt
+++ b/init.txt
@@ -1,2 +1,2 @@
 this is the first file.
-second line info add.
+77 second line info add.
diff --git a/second.txt b/second.txt
index 269c38a..0ef8073 100644
--- a/second.txt
+++ b/second.txt
@@ -1 +1,2 @@
-this is the second file
\ No newline at end of file
+this is the second file
+3434`
```


对比工作区与暂存区（未暂存的改动）
```shell
git diff
# 或者 git diff --staged
```
- 显示 所有已跟踪文件中未暂存的改动
- 包含新增、删除或修改的行

对比暂存区与 HEAD（已暂存但未提交的改动）
```shell
git diff --cached
# 或者 git diff --staged
```
- 显示已经 git add 暂存的改动
- 用于查看下一次 commit 会提交哪些内容

对比工作区与 HEAD（包括已暂存 + 未暂存的改动）
```shell
git diff HEAD
# 或者 git diff --staged
```
- 显示整个项目自上次 commit 以来的所有改动
- 包括暂存区和工作区的改动

对比两个分支或两个提交
```shell
git diff branch1 branch2
# 或者指定 commit
git diff <commit1> <commit2>
```
- 对比两个分支或提交的差异
- 可以用 --name-only 只看文件列表，或 --stat 看统计信息


对比整个项目文件名或统计信息
```shell
git diff --name-only HEAD
# 输出修改过的文件列表
git diff --stat HEAD
# 输出修改文件的行数统计
```


## 3.4 临时保存（git stash）
把当前工作区和暂存区的改动存起来，让工作区恢复干净状态（和 HEAD 一致）。

场景：
- 功能开发没完成，需要临时切换到别的分支修 Bug
- 拉代码前把本地改动先放一边，避免冲突

常用命令：
```shell
git stash push -m "描述信息"   # 推荐用法
git stash              # 等价于 push，保存所有已跟踪的改动
git stash -u           # 保存包括未跟踪文件
git stash -a           # 保存包括未跟踪 + 忽略文件

git stash list
# 输出示例：
# stash@{0}: On dev: WIP: 登录功能
# stash@{1}: On main: 修复样式

git stash apply stash@{0}   # 应用 stash，保留 stash 记录
git stash pop stash@{0}     # 应用并删除 stash（常用）

git stash drop stash@{0}    # 删除指定 stash
git stash clear             # 清空所有 stash
```

进阶用法：
```shell
# 只保存某个文件
git stash push -m "保存 main.c" main.c  

# 只保存暂存区的改动
git stash push --staged    

# 保直接从 stash 创建分支（基于 stash 新建分支并恢复改动）
git stash branch new-feature stash@{1}  

```

工作流程图
```
        ┌───────────────┐
        │ 工作区有改动   │
        └───────┬───────┘
                │
         git stash push
                │
   ┌────────────▼────────────┐
   │ 改动存入 stash 栈中      │
   │ 工作区恢复到干净状态    │
   └───────┬────────┬───────┘
           │        │
    git stash list  │
                    │
          ┌─────────▼─────────┐
          │ 取出改动           │
          │ git stash apply    │
          │ 或 git stash pop   │
          └─────────┬─────────┘
                    │
          ┌─────────▼─────────┐
          │ 改动恢复到工作区   │
          │ pop 会自动删除栈项 │
          └───────────────────┘
```


git stash 存储的内容
- 工作区（working directory） 已跟踪文件的修改（即你编辑过但还没 git add 的部分）
- 暂存区（staging area / index） 已经 git add 的修改
- 不包括：
  1. 默认不会保存 未跟踪文件（新建但没 git add）
  2. 默认不会保存 被忽略的文件（.gitignore 里的）, 如果要包含这些，需要加参数：
     - -u (--include-untracked) → 保存未跟踪文件
     - -a (--all) → 保存未跟踪 + 忽略文件


执行 git stash 之后的状态
- Git 会把当前的修改 打包成一个 stash 对象（存到 .git/refs/stash 里）。
- 工作区和暂存区会被恢复到 HEAD（当前分支最新提交）时的状态。就像你没有任何未提交的改动，分支变“干净”了。


注意：恢复时如果存在冲突，需要先解决冲突，流程如下


1. 执行 git stash pop
```shell
git stash pop 
```
Git 尝试应用 stash 改动；如果冲突，会提示哪些文件有冲突

2. 查看冲突
```shell
git status
```
会显示 unmerged paths

3. 解决冲突
  - 打开冲突文件，手动合并
  - 保存修改后执行
```shell
git add <冲突文件>
```
4. 完成 stash 合并
```shell
git commit
```
注意：如果 stash pop 成功应用没有冲突，就不需要 commit，因为 stash 中的修改已经直接应用到工作区


使用建议：
- 开发分支没完成的改动 → stash 保存 → 切换分支修 Bug → 回来后 pop
- 短期临时存放 → 用 pop（一次性用完就删）
- 长期存放/多次使用 → 用 apply（保留 stash 记录）
- 注意 未跟踪文件默认不保存，需要 -u 或 -a